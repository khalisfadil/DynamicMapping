/**
 * SFunctionDynamicMapping.cpp
 *
 *    ABSTRACT:
 *      The purpose of this sfunction is to call a simple legacy
 *      function during simulation:
 *
 *         void OutputDynamicMapping(uint32 u1, single u2[128*1024][3], single u3[128*1024][1],single u4[128*1024][1], single u5[128*1024][1],single u6[3][1], uint32 u7, single u8, single u9, single u10[3][1],single u11, uint32 u12, uint32 u13, single u14, single u15, single u16, single u17,single u18, single u19, double u20,single y1[128*1024*5][3], uint32 y2, single y3[128*1024][3], uint32 y4,uint32 y5[128*1024*5][3], uint32 y6[128*1024*5][3], uint32 y7[128*1024*5][3],uint32 y8[128*1024*5][3], uint32 y9[128*1024][3])
 *
 *    Simulink version           : 23.2 (R2023b) 01-Aug-2023
 *    C++ source code generated on : 20-Nov-2024 09:50:17
 *
 * THIS S-FUNCTION IS GENERATED BY THE LEGACY CODE TOOL AND MAY NOT WORK IF MODIFIED
 */

/**
     %%%-MATLAB_Construction_Commands_Start
     def = legacy_code('initialize');
     def.SFunctionName = 'SFunctionDynamicMapping';
     def.OutputFcnSpec = 'void OutputDynamicMapping(uint32 u1, single u2[128*1024][3], single u3[128*1024][1],single u4[128*1024][1], single u5[128*1024][1],single u6[3][1], uint32 u7, single u8, single u9, single u10[3][1],single u11, uint32 u12, uint32 u13, single u14, single u15, single u16, single u17,single u18, single u19, double u20,single y1[128*1024*5][3], uint32 y2, single y3[128*1024][3], uint32 y4,uint32 y5[128*1024*5][3], uint32 y6[128*1024*5][3], uint32 y7[128*1024*5][3],uint32 y8[128*1024*5][3], uint32 y9[128*1024][3])';
     def.StartFcnSpec = 'void CreateDynamicMapping()';
     def.TerminateFcnSpec = 'void DeleteDynamicMapping()';
     def.HeaderFiles = {'dynamicMapping.hpp', 'M_occupancyMap.hpp', 'M_clusterExtractor.hpp', 'M_EKFVelocity2D.hpp', 'robin_growth_policy.h', 'robin_hash.h', 'robin_map.h', 'robin_set.h'};
     def.SourceFiles = {'dynamicMapping.cpp', 'M_occupancyMap.cpp', 'M_clusterExtractor.cpp', 'M_EKFVelocity2D.cpp'};
     def.IncPaths = {'/home/khalis/Workspace/SensorSOW/SynologyDrive/Arbeitspakete/MATLAB/Developement/020_DynamicMapping/matlab/library/source/code', '/home/khalis/Workspace/SensorSOW/SynologyDrive/Arbeitspakete/MATLAB/Developement/020_DynamicMapping/matlab/library/source/code/tsl'};
     def.SrcPaths = {'/home/khalis/Workspace/SensorSOW/SynologyDrive/Arbeitspakete/MATLAB/Developement/020_DynamicMapping/matlab/library/source/code', '/home/khalis/Workspace/SensorSOW/SynologyDrive/Arbeitspakete/MATLAB/Developement/020_DynamicMapping/matlab/library/source/code/tsl'};
     def.SampleTime = 'parameterized';
     def.Options.useTlcWithAccel = false;
     def.Options.language = 'C++';
     legacy_code('sfcn_cmex_generate', def);
     legacy_code('compile', def);
     %%%-MATLAB_Construction_Commands_End
 */

/* Must specify the S_FUNCTION_NAME as the name of the S-function */
#define S_FUNCTION_NAME  SFunctionDynamicMapping
#define S_FUNCTION_LEVEL 2

/**
 * Need to include simstruc.h for the definition of the SimStruct and
 * its associated macro definitions.
 */
#include "simstruc.h"

/* Ensure that this S-Function is compiled with a C++ compiler */
#ifndef __cplusplus
#error This S-Function must be compiled with a C++ compiler. Enter mex('-setup') in the MATLAB Command Window to configure a C++ compiler.
#endif

/* Specific header file(s) required by the legacy code function */
#include "dynamicMapping.hpp"
#include "M_occupancyMap.hpp"
#include "M_clusterExtractor.hpp"
#include "M_EKFVelocity2D.hpp"
#include "robin_growth_policy.h"
#include "robin_hash.h"
#include "robin_map.h"
#include "robin_set.h"

#define EDIT_OK(S, P_IDX) \
       (!((ssGetSimMode(S)==SS_SIMMODE_SIZES_CALL_ONLY) && mxIsEmpty(ssGetSFcnParam(S, P_IDX))))

#define SAMPLE_TIME (ssGetSFcnParam(S, 0))


/* Utility function prototypes */
static boolean_T IsRealMatrix(const mxArray *m);

#define MDL_CHECK_PARAMETERS
#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)
/* Function: mdlCheckParameters ===========================================
 * Abstract:
 *   mdlCheckParameters verifies new parameter settings whenever parameter
 *   change or are re-evaluated during a simulation. When a simulation is
 *   running, changes to S-function parameters can occur at any time during
 *   the simulation loop.
 */
static void mdlCheckParameters(SimStruct *S)
{
    /* Check the parameter 1 (sample time) */
    if (EDIT_OK(S, 0)) {
        real_T  *sampleTime = NULL;
        size_t  stArraySize = mxGetM(SAMPLE_TIME) * mxGetN(SAMPLE_TIME);

        /* Sample time must be a real scalar value or 2 element array */
        if (IsRealMatrix(SAMPLE_TIME) && (stArraySize == 1 || stArraySize == 2)) {
            sampleTime = (real_T *) mxGetPr(SAMPLE_TIME);
        } else {
            ssSetErrorStatus(S, "Invalid sample time. Sample time must be a real scalar value or an array of two real values.");
            return;
        } /* if */

        if (sampleTime[0] < 0.0 && sampleTime[0] != -1.0) {
            ssSetErrorStatus(S, "Invalid sample time. Period must be non-negative or -1 (for inherited).");
            return;
        } /* if */

        if (stArraySize == 2 && sampleTime[0] > 0.0 && sampleTime[1] >= sampleTime[0]) {
            ssSetErrorStatus(S, "Invalid sample time. Offset must be smaller than period.");
            return;
        } /* if */

        if (stArraySize == 2 && sampleTime[0] == -1.0 && sampleTime[1] != 0.0) {
            ssSetErrorStatus(S, "Invalid sample time. When period is -1, offset must be 0.");
            return;
        } /* if */

        if (stArraySize == 2 && sampleTime[0] == 0.0 && !(sampleTime[1] == 1.0)) {
            ssSetErrorStatus(S, "Invalid sample time. When period is 0, offset must be 1.");
            return;
        } /* if */
    } /* if */

}
#endif

#define MDL_PROCESS_PARAMETERS
#if defined(MDL_PROCESS_PARAMETERS) && defined(MATLAB_MEX_FILE)
/* Function: mdlProcessParameters =========================================
 * Abstract:
 *   Update run-time parameters.
 */
static void mdlProcessParameters(SimStruct *S)
{
    ssUpdateAllTunableParamsAsRunTimeParams(S);
}
#endif

/* Function: mdlInitializeSizes ===========================================
 * Abstract:
 *   The sizes information is used by Simulink to determine the S-function
 *   block's characteristics (number of inputs, outputs, states, etc.).
 */
static void mdlInitializeSizes(SimStruct *S)
{
    /* Number of expected parameters */
    ssSetNumSFcnParams(S, 1);

    #if defined(MATLAB_MEX_FILE) 
    if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {
        /**
         * If the number of expected input parameters is not equal
         * to the number of parameters entered in the dialog box return.
         * Simulink will generate an error indicating that there is a
         * parameter mismatch.
         */
        mdlCheckParameters(S);
        if (ssGetErrorStatus(S) != NULL) return;
    } else {
        /* Return if number of expected != number of actual parameters */
        return;
    } /* if */
    #endif 

    /* Set the parameter's tunability */
    ssSetSFcnParamTunable(S, 0, 0);

    /* Set the number of work vectors */
    if (!ssSetNumDWork(S, 0)) return;
    ssSetNumPWork(S, 0);

    /* Set the number of input ports */
    if (!ssSetNumInputPorts(S, 20)) return;

    /* Configure the input port 1 */
    ssSetInputPortDataType(S, 0, SS_UINT32);
    {
        int_T u1Width = 1;
        ssSetInputPortWidth(S, 0, u1Width);
    }
    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 0, 1);
    ssSetInputPortAcceptExprInRTW(S, 0, 1);
    ssSetInputPortOverWritable(S, 0, 1);
    ssSetInputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 0, 1);
    ssSetInputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);

    /* Configure the input port 2 */
    ssSetInputPortDataType(S, 1, SS_SINGLE);
    {
        int_T u2NumRows = 131072;
        int_T u2NumCols = 3;
        ssSetInputPortMatrixDimensions(S, 1, u2NumRows, u2NumCols);
    }
    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 1, 1);
    ssSetInputPortAcceptExprInRTW(S, 1, 0);
    ssSetInputPortOverWritable(S, 1, 0);
    ssSetInputPortOptimOpts(S, 1, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 1, 1);
    ssSetInputPortDimensionsMode(S, 1, FIXED_DIMS_MODE);

    /* Configure the input port 3 */
    ssSetInputPortDataType(S, 2, SS_SINGLE);
    {
        int_T u3NumRows = 131072;
        int_T u3NumCols = 1;
        ssSetInputPortMatrixDimensions(S, 2, u3NumRows, u3NumCols);
    }
    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 2, 1);
    ssSetInputPortAcceptExprInRTW(S, 2, 0);
    ssSetInputPortOverWritable(S, 2, 0);
    ssSetInputPortOptimOpts(S, 2, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 2, 1);
    ssSetInputPortDimensionsMode(S, 2, FIXED_DIMS_MODE);

    /* Configure the input port 4 */
    ssSetInputPortDataType(S, 3, SS_SINGLE);
    {
        int_T u4NumRows = 131072;
        int_T u4NumCols = 1;
        ssSetInputPortMatrixDimensions(S, 3, u4NumRows, u4NumCols);
    }
    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 3, 1);
    ssSetInputPortAcceptExprInRTW(S, 3, 0);
    ssSetInputPortOverWritable(S, 3, 0);
    ssSetInputPortOptimOpts(S, 3, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 3, 1);
    ssSetInputPortDimensionsMode(S, 3, FIXED_DIMS_MODE);

    /* Configure the input port 5 */
    ssSetInputPortDataType(S, 4, SS_SINGLE);
    {
        int_T u5NumRows = 131072;
        int_T u5NumCols = 1;
        ssSetInputPortMatrixDimensions(S, 4, u5NumRows, u5NumCols);
    }
    ssSetInputPortComplexSignal(S, 4, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 4, 1);
    ssSetInputPortAcceptExprInRTW(S, 4, 0);
    ssSetInputPortOverWritable(S, 4, 0);
    ssSetInputPortOptimOpts(S, 4, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 4, 1);
    ssSetInputPortDimensionsMode(S, 4, FIXED_DIMS_MODE);

    /* Configure the input port 6 */
    ssSetInputPortDataType(S, 5, SS_SINGLE);
    {
        int_T u6NumRows = 3;
        int_T u6NumCols = 1;
        ssSetInputPortMatrixDimensions(S, 5, u6NumRows, u6NumCols);
    }
    ssSetInputPortComplexSignal(S, 5, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 5, 1);
    ssSetInputPortAcceptExprInRTW(S, 5, 0);
    ssSetInputPortOverWritable(S, 5, 0);
    ssSetInputPortOptimOpts(S, 5, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 5, 1);
    ssSetInputPortDimensionsMode(S, 5, FIXED_DIMS_MODE);

    /* Configure the input port 7 */
    ssSetInputPortDataType(S, 6, SS_UINT32);
    {
        int_T u7Width = 1;
        ssSetInputPortWidth(S, 6, u7Width);
    }
    ssSetInputPortComplexSignal(S, 6, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 6, 1);
    ssSetInputPortAcceptExprInRTW(S, 6, 1);
    ssSetInputPortOverWritable(S, 6, 1);
    ssSetInputPortOptimOpts(S, 6, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 6, 1);
    ssSetInputPortDimensionsMode(S, 6, FIXED_DIMS_MODE);

    /* Configure the input port 8 */
    ssSetInputPortDataType(S, 7, SS_SINGLE);
    {
        int_T u8Width = 1;
        ssSetInputPortWidth(S, 7, u8Width);
    }
    ssSetInputPortComplexSignal(S, 7, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 7, 1);
    ssSetInputPortAcceptExprInRTW(S, 7, 1);
    ssSetInputPortOverWritable(S, 7, 1);
    ssSetInputPortOptimOpts(S, 7, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 7, 1);
    ssSetInputPortDimensionsMode(S, 7, FIXED_DIMS_MODE);

    /* Configure the input port 9 */
    ssSetInputPortDataType(S, 8, SS_SINGLE);
    {
        int_T u9Width = 1;
        ssSetInputPortWidth(S, 8, u9Width);
    }
    ssSetInputPortComplexSignal(S, 8, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 8, 1);
    ssSetInputPortAcceptExprInRTW(S, 8, 1);
    ssSetInputPortOverWritable(S, 8, 1);
    ssSetInputPortOptimOpts(S, 8, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 8, 1);
    ssSetInputPortDimensionsMode(S, 8, FIXED_DIMS_MODE);

    /* Configure the input port 10 */
    ssSetInputPortDataType(S, 9, SS_SINGLE);
    {
        int_T u10NumRows = 3;
        int_T u10NumCols = 1;
        ssSetInputPortMatrixDimensions(S, 9, u10NumRows, u10NumCols);
    }
    ssSetInputPortComplexSignal(S, 9, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 9, 1);
    ssSetInputPortAcceptExprInRTW(S, 9, 0);
    ssSetInputPortOverWritable(S, 9, 0);
    ssSetInputPortOptimOpts(S, 9, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 9, 1);
    ssSetInputPortDimensionsMode(S, 9, FIXED_DIMS_MODE);

    /* Configure the input port 11 */
    ssSetInputPortDataType(S, 10, SS_SINGLE);
    {
        int_T u11Width = 1;
        ssSetInputPortWidth(S, 10, u11Width);
    }
    ssSetInputPortComplexSignal(S, 10, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 10, 1);
    ssSetInputPortAcceptExprInRTW(S, 10, 1);
    ssSetInputPortOverWritable(S, 10, 1);
    ssSetInputPortOptimOpts(S, 10, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 10, 1);
    ssSetInputPortDimensionsMode(S, 10, FIXED_DIMS_MODE);

    /* Configure the input port 12 */
    ssSetInputPortDataType(S, 11, SS_UINT32);
    {
        int_T u12Width = 1;
        ssSetInputPortWidth(S, 11, u12Width);
    }
    ssSetInputPortComplexSignal(S, 11, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 11, 1);
    ssSetInputPortAcceptExprInRTW(S, 11, 1);
    ssSetInputPortOverWritable(S, 11, 1);
    ssSetInputPortOptimOpts(S, 11, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 11, 1);
    ssSetInputPortDimensionsMode(S, 11, FIXED_DIMS_MODE);

    /* Configure the input port 13 */
    ssSetInputPortDataType(S, 12, SS_UINT32);
    {
        int_T u13Width = 1;
        ssSetInputPortWidth(S, 12, u13Width);
    }
    ssSetInputPortComplexSignal(S, 12, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 12, 1);
    ssSetInputPortAcceptExprInRTW(S, 12, 1);
    ssSetInputPortOverWritable(S, 12, 1);
    ssSetInputPortOptimOpts(S, 12, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 12, 1);
    ssSetInputPortDimensionsMode(S, 12, FIXED_DIMS_MODE);

    /* Configure the input port 14 */
    ssSetInputPortDataType(S, 13, SS_SINGLE);
    {
        int_T u14Width = 1;
        ssSetInputPortWidth(S, 13, u14Width);
    }
    ssSetInputPortComplexSignal(S, 13, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 13, 1);
    ssSetInputPortAcceptExprInRTW(S, 13, 1);
    ssSetInputPortOverWritable(S, 13, 1);
    ssSetInputPortOptimOpts(S, 13, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 13, 1);
    ssSetInputPortDimensionsMode(S, 13, FIXED_DIMS_MODE);

    /* Configure the input port 15 */
    ssSetInputPortDataType(S, 14, SS_SINGLE);
    {
        int_T u15Width = 1;
        ssSetInputPortWidth(S, 14, u15Width);
    }
    ssSetInputPortComplexSignal(S, 14, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 14, 1);
    ssSetInputPortAcceptExprInRTW(S, 14, 1);
    ssSetInputPortOverWritable(S, 14, 1);
    ssSetInputPortOptimOpts(S, 14, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 14, 1);
    ssSetInputPortDimensionsMode(S, 14, FIXED_DIMS_MODE);

    /* Configure the input port 16 */
    ssSetInputPortDataType(S, 15, SS_SINGLE);
    {
        int_T u16Width = 1;
        ssSetInputPortWidth(S, 15, u16Width);
    }
    ssSetInputPortComplexSignal(S, 15, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 15, 1);
    ssSetInputPortAcceptExprInRTW(S, 15, 1);
    ssSetInputPortOverWritable(S, 15, 1);
    ssSetInputPortOptimOpts(S, 15, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 15, 1);
    ssSetInputPortDimensionsMode(S, 15, FIXED_DIMS_MODE);

    /* Configure the input port 17 */
    ssSetInputPortDataType(S, 16, SS_SINGLE);
    {
        int_T u17Width = 1;
        ssSetInputPortWidth(S, 16, u17Width);
    }
    ssSetInputPortComplexSignal(S, 16, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 16, 1);
    ssSetInputPortAcceptExprInRTW(S, 16, 1);
    ssSetInputPortOverWritable(S, 16, 1);
    ssSetInputPortOptimOpts(S, 16, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 16, 1);
    ssSetInputPortDimensionsMode(S, 16, FIXED_DIMS_MODE);

    /* Configure the input port 18 */
    ssSetInputPortDataType(S, 17, SS_SINGLE);
    {
        int_T u18Width = 1;
        ssSetInputPortWidth(S, 17, u18Width);
    }
    ssSetInputPortComplexSignal(S, 17, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 17, 1);
    ssSetInputPortAcceptExprInRTW(S, 17, 1);
    ssSetInputPortOverWritable(S, 17, 1);
    ssSetInputPortOptimOpts(S, 17, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 17, 1);
    ssSetInputPortDimensionsMode(S, 17, FIXED_DIMS_MODE);

    /* Configure the input port 19 */
    ssSetInputPortDataType(S, 18, SS_SINGLE);
    {
        int_T u19Width = 1;
        ssSetInputPortWidth(S, 18, u19Width);
    }
    ssSetInputPortComplexSignal(S, 18, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 18, 1);
    ssSetInputPortAcceptExprInRTW(S, 18, 1);
    ssSetInputPortOverWritable(S, 18, 1);
    ssSetInputPortOptimOpts(S, 18, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 18, 1);
    ssSetInputPortDimensionsMode(S, 18, FIXED_DIMS_MODE);

    /* Configure the input port 20 */
    ssSetInputPortDataType(S, 19, SS_DOUBLE);
    {
        int_T u20Width = 1;
        ssSetInputPortWidth(S, 19, u20Width);
    }
    ssSetInputPortComplexSignal(S, 19, COMPLEX_NO);
    ssSetInputPortDirectFeedThrough(S, 19, 1);
    ssSetInputPortAcceptExprInRTW(S, 19, 1);
    ssSetInputPortOverWritable(S, 19, 1);
    ssSetInputPortOptimOpts(S, 19, SS_REUSABLE_AND_LOCAL);
    ssSetInputPortRequiredContiguous(S, 19, 1);
    ssSetInputPortDimensionsMode(S, 19, FIXED_DIMS_MODE);

    /* Set the number of output ports */
    if (!ssSetNumOutputPorts(S, 9)) return;

    /* Configure the output port 1 */
    ssSetOutputPortDataType(S, 0, SS_SINGLE);
    {
        int_T y1NumRows = 655360;
        int_T y1NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 0, y1NumRows, y1NumCols);
    }
    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 0, 0);
    ssSetOutputPortDimensionsMode(S, 0, FIXED_DIMS_MODE);

    /* Configure the output port 2 */
    ssSetOutputPortDataType(S, 1, SS_UINT32);
    {
        int_T y2Width = 1;
        ssSetOutputPortWidth(S, 1, y2Width);
    }
    ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 1, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 1, 0);
    ssSetOutputPortDimensionsMode(S, 1, FIXED_DIMS_MODE);

    /* Configure the output port 3 */
    ssSetOutputPortDataType(S, 2, SS_SINGLE);
    {
        int_T y3NumRows = 131072;
        int_T y3NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 2, y3NumRows, y3NumCols);
    }
    ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 2, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 2, 0);
    ssSetOutputPortDimensionsMode(S, 2, FIXED_DIMS_MODE);

    /* Configure the output port 4 */
    ssSetOutputPortDataType(S, 3, SS_UINT32);
    {
        int_T y4Width = 1;
        ssSetOutputPortWidth(S, 3, y4Width);
    }
    ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 3, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 3, 0);
    ssSetOutputPortDimensionsMode(S, 3, FIXED_DIMS_MODE);

    /* Configure the output port 5 */
    ssSetOutputPortDataType(S, 4, SS_UINT32);
    {
        int_T y5NumRows = 655360;
        int_T y5NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 4, y5NumRows, y5NumCols);
    }
    ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 4, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 4, 0);
    ssSetOutputPortDimensionsMode(S, 4, FIXED_DIMS_MODE);

    /* Configure the output port 6 */
    ssSetOutputPortDataType(S, 5, SS_UINT32);
    {
        int_T y6NumRows = 655360;
        int_T y6NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 5, y6NumRows, y6NumCols);
    }
    ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 5, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 5, 0);
    ssSetOutputPortDimensionsMode(S, 5, FIXED_DIMS_MODE);

    /* Configure the output port 7 */
    ssSetOutputPortDataType(S, 6, SS_UINT32);
    {
        int_T y7NumRows = 655360;
        int_T y7NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 6, y7NumRows, y7NumCols);
    }
    ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 6, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 6, 0);
    ssSetOutputPortDimensionsMode(S, 6, FIXED_DIMS_MODE);

    /* Configure the output port 8 */
    ssSetOutputPortDataType(S, 7, SS_UINT32);
    {
        int_T y8NumRows = 655360;
        int_T y8NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 7, y8NumRows, y8NumCols);
    }
    ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 7, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 7, 0);
    ssSetOutputPortDimensionsMode(S, 7, FIXED_DIMS_MODE);

    /* Configure the output port 9 */
    ssSetOutputPortDataType(S, 8, SS_UINT32);
    {
        int_T y9NumRows = 131072;
        int_T y9NumCols = 3;
        ssSetOutputPortMatrixDimensions(S, 8, y9NumRows, y9NumCols);
    }
    ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 8, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 8, 0);
    ssSetOutputPortDimensionsMode(S, 8, FIXED_DIMS_MODE);

    /* Register reserved identifiers to avoid name conflict */
    if (ssRTWGenIsCodeGen(S) || ssGetSimMode(S)==SS_SIMMODE_EXTERNAL) {

        /* Register reserved identifier for  */
        ssRegMdlInfo(S, "CreateDynamicMapping", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));

        /* Register reserved identifier for  */
        ssRegMdlInfo(S, "OutputDynamicMapping", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));

        /* Register reserved identifier for  */
        ssRegMdlInfo(S, "DeleteDynamicMapping", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));

        /* Register reserved identifier for wrappers */
        if (ssRTWGenIsModelReferenceSimTarget(S)) {

            /* Register reserved identifier for  */
            ssRegMdlInfo(S, "CreateDynamicMapping_wrapper_Start", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));

            /* Register reserved identifier for  */
            ssRegMdlInfo(S, "OutputDynamicMapping_wrapper_Output", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));

            /* Register reserved identifier for  */
            ssRegMdlInfo(S, "DeleteDynamicMapping_wrapper_Terminate", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));
        } /* if */
    } /* if */

    /* This S-function can be used in referenced model simulating in normal mode */
    ssSetModelReferenceNormalModeSupport(S, MDL_START_AND_MDL_PROCESS_PARAMS_OK);

    /* Set the number of sample time */
    ssSetNumSampleTimes(S, 1);

    /* Set the compliance for the operating point save/restore. */
    ssSetOperatingPointCompliance(S, USE_DEFAULT_OPERATING_POINT);

    ssSetArrayLayoutForCodeGen(S, SS_COLUMN_MAJOR);

    /* Set the Simulink version this S-Function has been generated in */
    ssSetSimulinkVersionGeneratedIn(S, "23.2");

    /**
     * All options have the form SS_OPTION_<name> and are documented in
     * matlabroot/simulink/include/simstruc.h. The options should be
     * bitwise or'd together as in
     *    ssSetOptions(S, (SS_OPTION_name1 | SS_OPTION_name2))
     */
    ssSetOptions(S,
        SS_OPTION_CAN_BE_CALLED_CONDITIONALLY |
        SS_OPTION_EXCEPTION_FREE_CODE |
        SS_OPTION_WORKS_WITH_CODE_REUSE |
        SS_OPTION_SFUNCTION_INLINED_FOR_RTW |
        SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME
    );
}

/* Function: mdlInitializeSampleTimes =====================================
 * Abstract:
 *   This function is used to specify the sample time(s) for your
 *   S-function. You must register the same number of sample times as
 *   specified in ssSetNumSampleTimes.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
    real_T * sampleTime = (real_T*) (mxGetPr(SAMPLE_TIME));
    size_t  stArraySize = mxGetM(SAMPLE_TIME) * mxGetN(SAMPLE_TIME);

    ssSetSampleTime(S, 0, sampleTime[0]);
    if (stArraySize == 1) {
        ssSetOffsetTime(S, 0, (sampleTime[0] == CONTINUOUS_SAMPLE_TIME ? FIXED_IN_MINOR_STEP_OFFSET: 0.0));
    } else {
        ssSetOffsetTime(S, 0, sampleTime[1]);
    } /* if */

    #if defined(ssSetModelReferenceSampleTimeDefaultInheritance)
    ssSetModelReferenceSampleTimeDefaultInheritance(S);
    #endif
}

#define MDL_START
#if defined(MDL_START)
/* Function: mdlStart =====================================================
 * Abstract:
 *   This function is called once at start of model execution. If you
 *   have states that should be initialized once, this is the place
 *   to do it.
 */
static void mdlStart(SimStruct *S)
{

    /* Call the legacy code function */
    CreateDynamicMapping();
}
#endif

/* Function: mdlOutputs ===================================================
 * Abstract:
 *   In this function, you compute the outputs of your S-function
 *   block. Generally outputs are placed in the output vector(s),
 *   ssGetOutputPortSignal.
 */
static void mdlOutputs(SimStruct *S, int_T tid)
{

    /* Get access to Parameter/Input/Output/DWork data */
    uint32_T* u1 = (uint32_T*) ssGetInputPortSignal(S, 0);
    real32_T* u2 = (real32_T*) ssGetInputPortSignal(S, 1);
    real32_T* u3 = (real32_T*) ssGetInputPortSignal(S, 2);
    real32_T* u4 = (real32_T*) ssGetInputPortSignal(S, 3);
    real32_T* u5 = (real32_T*) ssGetInputPortSignal(S, 4);
    real32_T* u6 = (real32_T*) ssGetInputPortSignal(S, 5);
    uint32_T* u7 = (uint32_T*) ssGetInputPortSignal(S, 6);
    real32_T* u8 = (real32_T*) ssGetInputPortSignal(S, 7);
    real32_T* u9 = (real32_T*) ssGetInputPortSignal(S, 8);
    real32_T* u10 = (real32_T*) ssGetInputPortSignal(S, 9);
    real32_T* u11 = (real32_T*) ssGetInputPortSignal(S, 10);
    uint32_T* u12 = (uint32_T*) ssGetInputPortSignal(S, 11);
    uint32_T* u13 = (uint32_T*) ssGetInputPortSignal(S, 12);
    real32_T* u14 = (real32_T*) ssGetInputPortSignal(S, 13);
    real32_T* u15 = (real32_T*) ssGetInputPortSignal(S, 14);
    real32_T* u16 = (real32_T*) ssGetInputPortSignal(S, 15);
    real32_T* u17 = (real32_T*) ssGetInputPortSignal(S, 16);
    real32_T* u18 = (real32_T*) ssGetInputPortSignal(S, 17);
    real32_T* u19 = (real32_T*) ssGetInputPortSignal(S, 18);
    real_T* u20 = (real_T*) ssGetInputPortSignal(S, 19);
    real32_T* y1 = (real32_T*) ssGetOutputPortSignal(S, 0);
    uint32_T* y2 = (uint32_T*) ssGetOutputPortSignal(S, 1);
    real32_T* y3 = (real32_T*) ssGetOutputPortSignal(S, 2);
    uint32_T* y4 = (uint32_T*) ssGetOutputPortSignal(S, 3);
    uint32_T* y5 = (uint32_T*) ssGetOutputPortSignal(S, 4);
    uint32_T* y6 = (uint32_T*) ssGetOutputPortSignal(S, 5);
    uint32_T* y7 = (uint32_T*) ssGetOutputPortSignal(S, 6);
    uint32_T* y8 = (uint32_T*) ssGetOutputPortSignal(S, 7);
    uint32_T* y9 = (uint32_T*) ssGetOutputPortSignal(S, 8);


    /* Call the legacy code function */
    OutputDynamicMapping(*u1, u2, u3, u4, u5, u6, *u7, *u8, *u9, u10, *u11, *u12, *u13, *u14, *u15, *u16, *u17, *u18, *u19, *u20, y1, *y2, y3, *y4, y5, y6, y7, y8, y9);
}

/* Function: mdlTerminate =================================================
 * Abstract:
 *   In this function, you should perform any actions that are necessary
 *   at the termination of a simulation.
 */
static void mdlTerminate(SimStruct *S)
{

    /* Call the legacy code function */
    DeleteDynamicMapping();
}

#define MDL_RTW
#if defined(MATLAB_MEX_FILE) && defined(MDL_RTW)
/* Function: mdlRTW =======================================================
 * Abstract:
 *   This function is called when Simulink Coder is generating
 *   the model.rtw file.
 */
static void mdlRTW(SimStruct *S)
{
}
#endif

/* Function: IsRealMatrix =================================================
 * Abstract:
 *   Verify that the mxArray is a real (double) finite matrix
 */
boolean_T IsRealMatrix(const mxArray *m)
{
    if (mxIsNumeric(m) && mxIsDouble(m) && !mxIsLogical(m) && !mxIsComplex(m) && !mxIsSparse(m) && !mxIsEmpty(m) && (mxGetNumberOfDimensions(m)==2)) {
        real_T *data = mxGetPr(m);
        size_t  numEl = mxGetNumberOfElements(m);
        size_t  i;

        for (i = 0; i < numEl; i++) {
            if (!mxIsFinite(data[i])) {
                return 0;
            } /* if */
        } /* for */

        return 1;
    } else {
        return 0;
    } /* if */
}

/* Required S-function trailer */
#ifdef    MATLAB_MEX_FILE
# include "simulink.c"
#else
# include "cg_sfun.h"
#endif

